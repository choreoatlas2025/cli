// SPDX-FileCopyrightText: 2025 ChoreoAtlas contributors
// SPDX-License-Identifier: Apache-2.0

package cli

import (
	"flag"
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/choreoatlas2025/cli/internal/spec"
	"github.com/choreoatlas2025/cli/internal/trace"
)

func runDiscover(args []string) {
    fs := flag.NewFlagSet("discover", flag.ExitOnError)
    tracePath := fs.String("trace", "", "trace.json file path")
    out := fs.String("out", "discovered.flowspec.yaml", "FlowSpec output path")
    outServices := fs.String("out-services", "./services", "ServiceSpec output directory")
    title := fs.String("title", "Flow generated from trace", "FlowSpec title")
    noValidate := fs.Bool("no-validate", false, "Skip schema + lint validation gate (not recommended)")
    _ = fs.Parse(args)

	if *tracePath == "" {
		exitErr(fmt.Errorf("--trace parameter is required"))
	}

	tr, err := trace.LoadFromFile(*tracePath)
	if err != nil {
		exitErr(err)
	}

	// 按时间排序 spans
	sort.Slice(tr.Spans, func(i, j int) bool {
		return tr.Spans[i].StartNanos < tr.Spans[j].StartNanos
	})

    // 生成 FlowSpec YAML（先不落盘，先生成 ServiceSpec 与校验）
    yml := generateFlowYAML(tr, *title, *outServices)

    // 先生成 ServiceSpec 文件（FlowSpec 校验依赖其存在）
    if err := spec.GenerateServiceSpecs(tr.Spans, *outServices); err != nil {
        exitErr(fmt.Errorf("failed to generate ServiceSpec: %w", err))
    }

    if !*noValidate {
        if err := validateAndPersistFlow(yml, *out, *outServices); err != nil {
            exitErr(fmt.Errorf("generation failed schema/lint gate: %w", err))
        }
        fmt.Printf("Generated FlowSpec (validated): %s\n", *out)
    } else {
        if err := os.WriteFile(*out, []byte(yml), 0644); err != nil {
            exitErr(fmt.Errorf("failed to write file: %w", err))
        }
        fmt.Printf("Generated FlowSpec (no-validate): %s\n", *out)
    }

    fmt.Println("Dual contract generation complete! Please adjust the generated specifications as needed.")
}

// generateFlowYAML 从 trace 生成 FlowSpec YAML
func generateFlowYAML(tr *trace.Trace, title string, outServices string) string {
	var sb strings.Builder

	// Info 部分
	sb.WriteString("info:\n")
	sb.WriteString(fmt.Sprintf("  title: \"%s\"\n\n", title))

	// Services 部分
	services := make(map[string]struct{})
	for _, span := range tr.Spans {
		if span.Service != "" {
			services[span.Service] = struct{}{}
		}
	}

	sb.WriteString("services:\n")
	for service := range services {
		sb.WriteString(fmt.Sprintf("  %s:\n", service))
		sb.WriteString(fmt.Sprintf("    spec: \"%s/%s.servicespec.yaml\"\n", outServices, service))
	}
	sb.WriteString("\n")

	// Flow 部分
	sb.WriteString("flow:\n")
	for i, span := range tr.Spans {
		stepName := fmt.Sprintf("Step%d-%s", i+1, span.Name)
		if span.Service == "" || span.Name == "" {
			continue // 跳过无效的 span
		}

		sb.WriteString(fmt.Sprintf("  - step: \"%s\"\n", stepName))
		sb.WriteString(fmt.Sprintf("    call: \"%s.%s\"\n", span.Service, span.Name))

		// 生成示例 input（基于 attributes）
		if len(span.Attributes) > 0 {
			sb.WriteString("    input:\n")
			sb.WriteString("      body:\n")
			for key, value := range span.Attributes {
				// 简单的变量引用推断
				if strings.Contains(key, "Id") {
					sb.WriteString(fmt.Sprintf("        %s: \"${%s}\"  # TODO: Check variable reference\n", key, key))
				} else {
					sb.WriteString(fmt.Sprintf("        %s: %v  # TODO: Adjust input value\n", key, value))
				}
			}
		}

		// Generate output (assuming each step has a response)
		outputVar := fmt.Sprintf("%sResponse", strings.ToLower(span.Service))
		sb.WriteString("    output:\n")
		sb.WriteString(fmt.Sprintf("      %s: \"response.body\"  # TODO: Adjust output mapping\n", outputVar))

		sb.WriteString("\n")
	}

	// Add explanatory comments
	sb.WriteString("# This file was auto-generated by flowspec discover\n")
	sb.WriteString("# TODO list:\n")
	sb.WriteString("# 1. Create corresponding ServiceSpec files\n")
	sb.WriteString("# 2. Adjust input/output mappings and variable references\n")
	sb.WriteString("# 3. Verify step order and call relationships\n")
	sb.WriteString("# 4. Add appropriate meta information\n")

	return sb.String()
}
